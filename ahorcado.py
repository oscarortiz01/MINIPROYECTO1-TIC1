# -*- coding: utf-8 -*-
"""ahorcado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KyT4cu91erRKyj1OskHTZzVxDfqsDhHN
"""

import random
import threading
import time

# --- BIBLIOTECAS MODERNAS ---
from gpiozero import RGBLED, Button, TonalBuzzer
import board
import busio
import adafruit_ads1x15.ads1115 as ADS
from adafruit_ads1x15.analog_in import AnalogIn

# --- CONFIGURACI√ìN ---
i2c = busio.I2C(board.SCL, board.SDA)
ads = ADS.ADS1115(i2c)
chan_x = AnalogIn(ads, ADS.P0)
joy_button = Button(26, pull_up=True)
led1 = RGBLED(red=27, green=17, blue=22)
led2 = RGBLED(red=24, green=23, blue=25)
buzzer = TonalBuzzer(16)

# --- ESTADO COMPARTIDO ---
vidas_info = {"vidas": 0, "max": 1}
gpio_lock = threading.Lock()

# --- MELOD√çAS PERSONALIZADAS (CON NOTAS EN RANGO SEGURO) ---
def sonido_error_vida():
    """Tono corto y seco para indicar un error."""
    # CAMBIO FINAL: Usamos Do4 (261 Hz), una nota muy segura.
    buzzer.play(261)
    time.sleep(0.15)
    buzzer.stop()

def sonido_victoria():
    """Melod√≠a ascendente y alegre para la victoria."""
    # (Esta melod√≠a ya era segura)
    notas_victoria = [261, 329, 392, 523] # Do, Mi, Sol, Do alto
    for nota in notas_victoria:
        buzzer.play(nota)
        time.sleep(0.15)
        buzzer.stop()
        time.sleep(0.05)

def sonido_derrota():
    """Melod√≠a descendente y triste para la derrota."""
    # CAMBIO FINAL: Usamos notas seguras que descienden para dar la sensaci√≥n de derrota.
    buzzer.play(293) # Re4
    time.sleep(0.4)
    buzzer.stop()
    time.sleep(0.1)
    buzzer.play(261) # Do4
    time.sleep(0.8)
    buzzer.stop()

def actualizar_leds_estado(vidas, max_vidas):
    # (Sin cambios)
    with gpio_lock:
        vidas_info["vidas"] = vidas
        vidas_info["max"] = max(1, max_vidas)
        if vidas == max_vidas or vidas == max_vidas - 1:
            led1.color = (0, 1, 0)
        elif vidas > 1:
            led1.color = (1, 1, 0)
        else:
            led1.color = (1, 0, 0)

def blink_thread_func(stop_event, vidas_info_dict, lock):
    # (Sin cambios)
    MIN_PERIOD = 0.08
    MAX_PERIOD = 1.00
    while not stop_event.is_set():
        with lock:
            v = vidas_info_dict.get("vidas", 0)
            m = vidas_info_dict.get("max", 1)
        if v <= 0:
            led2.off()
            time.sleep(0.1)
            continue
        ratio = v / max(1, m)
        periodo = MIN_PERIOD + (MAX_PERIOD - MIN_PERIOD) * ratio
        led2.color = (1, 0, 0)
        if stop_event.wait(periodo): break
        led2.off()
        if stop_event.wait(periodo): break

def elegir_letra_con_joystick(letras_usadas):
    # (Sin cambios)
    alfabeto = "abcdefghijklmnopqrstuvwxyz"
    indice_letra = 0
    letra_seleccionada = None
    print("\nUsa el joystick para elegir una letra (Izquierda/Derecha) y presiona para seleccionar.")
    while letra_seleccionada is None:
        letra_actual = alfabeto[indice_letra]
        print(f"\rLetra actual: {letra_actual.upper()}", end="")
        x_val = chan_x.value
        if joy_button.is_pressed:
            letra_elegida = alfabeto[indice_letra]
            if letra_elegida in letras_usadas:
                print(f"\n¬°La letra '{letra_elegida.upper()}' ya fue usada! Elige otra.")
                time.sleep(1)
            else:
                letra_seleccionada = letra_elegida
                print(f"\nHas seleccionado: {letra_seleccionada.upper()}")
                time.sleep(0.5)
            continue
        if x_val > 25000:
            indice_letra = (indice_letra + 1) % len(alfabeto)
            time.sleep(0.2)
        elif x_val < 5000:
            indice_letra = (indice_letra - 1 + len(alfabeto)) % len(alfabeto)
            time.sleep(0.2)
    return letra_seleccionada

def leeyvalida(minimo, maximo, txt):
    # (Sin cambios)
    while True:
        try: n = int(input(txt))
        except ValueError: print("Error: ingresa un n√∫mero entero.")
        else:
            if minimo <= n <= maximo: return n
            print("Error, valor fuera de rango")

# Lista completa de Pok√©mon
pokemones = [
    "Bulbasaur","Ivysaur","Venusaur","Charmander","Charmeleon","Charizard","Squirtle","Wartortle","Blastoise","Caterpie","Metapod","Butterfree","Weedle","Kakuna","Beedrill","Pidgey","Pidgeotto","Pidgeot","Rattata","Raticate","Spearow","Fearow","Ekans","Arbok","Pikachu","Raichu","Sandshrew","Sandslash","Nidoran","Nidorina","Nidoqueen","Nidorino","Nidoking","Clefairy","Clefable","Vulpix","Ninetales","Jigglypuff","Wigglytuff","Zubat","Golbat","Oddish","Gloom","Vileplume","Paras","Parasect","Venonat","Venomoth","Diglett","Dugtrio","Meowth","Persian","Psyduck","Golduck","Mankey","Primeape","Growlithe","Arcanine","Poliwag","Poliwhirl","Poliwrath","Abra","Kadabra","Alakazam","Machop","Machoke","Machamp","Bellsprout","Weepinbell","Victreebel","Tentool","Tentacruel","Geodude","Graveler","Golem","Ponyta","Rapidash","Slowpoke","Slowbro","Magnemite","Magneton","Farfetchd","Doduo","Dodrio","Seel","Dewgong","Grimer","Muk","Shellder","Cloyster","Gastly","Haunter","Gengar","Onix","Drowzee","Hypno","Krabby","Kingler","Voltorb","Electrode","Exeggcute","Exeggutor","Cubone","Marowak","Hitmonlee","Hitmonchan","Lickitung","Koffing","Weezing","Rhyhorn","Rhydon","Chansey","Tangela","Kangaskhan","Horsea","Seadra","Goldeen","Seaking","Staryu","Starmie","MrMime","Scyther","Jynx","Electabuzz","Magmar","Pinsir","Tauros","Magikarp","Gyarados","Lapras","Ditto","Eevee","Vaporeon","Jolteon","Flareon","Porygon","Omanyte","Omastar","Kabuto","Kabutops","Aerodactyl","Snorlax","Articuno","Zapdos","Moltres","Dratini","Dragonair","Dragonite","Mewtwo","Mew"
]

def jugar():
    # (Sin cambios)
    while True:
        letras = leeyvalida(3, 10, "¬øCon cu√°ntas letras quieres jugar? (3-10): ")
        posibles = [p for p in pokemones if len(p) == letras]
        if posibles: break
        else: print("‚ö†Ô∏è No hay Pok√©mon con esa cantidad de letras. Intenta con otro n√∫mero.")
    palabra = random.choice(posibles).lower()
    oculta = ["_"] * len(palabra)
    max_vidas = leeyvalida(1, 20, "Ingrese el n√∫mero de vidas (1-20): ")
    vidas = max_vidas
    actualizar_leds_estado(vidas, max_vidas)
    print(f"¬°A jugar! El Pok√©mon tiene {len(palabra)} letras.")
    print(" ".join(oculta))
    usadas = set()

    while vidas > 0 and "_" in oculta:
        letra = elegir_letra_con_joystick(usadas)
        usadas.add(letra)
        if letra in palabra:
            for i, c in enumerate(palabra):
                if c == letra: oculta[i] = c
            print("¬°Correcto!")
        else:
            vidas -= 1
            print(f"Letra incorrecta. Te quedan {vidas} vidas.")
            sonido_error_vida()
            actualizar_leds_estado(vidas, max_vidas)
        print(" ".join(oculta))
        print("Letras usadas:", ", ".join(sorted(usadas)))

    if "_" not in oculta:
        print(f"üéâ ¬°Ganaste! El Pok√©mon era: {palabra.capitalize()}")
        sonido_victoria()
    else:
        print(f"‚ùå Te quedaste sin vidas. El Pok√©mon era: {palabra.capitalize()}")
        sonido_derrota()
    time.sleep(3)

# --- BUCLE PRINCIPAL ---
stop_event = threading.Event()
blink_thread = threading.Thread(target=blink_thread_func, args=(stop_event, vidas_info, gpio_lock), daemon=True)
blink_thread.start()
try:
    while True:
        jugar()
        seguir = input("¬øQuieres seguir jugando? (s/n): ").lower()
        if seguir != "s":
            print("Gracias por jugar, hasta la pr√≥xima!")
            break
except KeyboardInterrupt:
    print("\nInterrumpido por usuario.")
finally:
    stop_event.set()
    led1.off()
    led2.off()
    buzzer.stop()
    print("Limpiando y saliendo.")